// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'app_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$AppInitiated {}

/// @nodoc
abstract class $AppInitiatedCopyWith<$Res> {
  factory $AppInitiatedCopyWith(
          AppInitiated value, $Res Function(AppInitiated) then) =
      _$AppInitiatedCopyWithImpl<$Res, AppInitiated>;
}

/// @nodoc
class _$AppInitiatedCopyWithImpl<$Res, $Val extends AppInitiated>
    implements $AppInitiatedCopyWith<$Res> {
  _$AppInitiatedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AppInitiatedImplCopyWith<$Res> {
  factory _$$AppInitiatedImplCopyWith(
          _$AppInitiatedImpl value, $Res Function(_$AppInitiatedImpl) then) =
      __$$AppInitiatedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AppInitiatedImplCopyWithImpl<$Res>
    extends _$AppInitiatedCopyWithImpl<$Res, _$AppInitiatedImpl>
    implements _$$AppInitiatedImplCopyWith<$Res> {
  __$$AppInitiatedImplCopyWithImpl(
      _$AppInitiatedImpl _value, $Res Function(_$AppInitiatedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AppInitiatedImpl implements _AppInitiated {
  const _$AppInitiatedImpl();

  @override
  String toString() {
    return 'AppInitiated()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AppInitiatedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _AppInitiated implements AppInitiated {
  const factory _AppInitiated() = _$AppInitiatedImpl;
}

/// @nodoc
mixin _$AppLanguageChanged {
  String get locale => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AppLanguageChangedCopyWith<AppLanguageChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppLanguageChangedCopyWith<$Res> {
  factory $AppLanguageChangedCopyWith(
          AppLanguageChanged value, $Res Function(AppLanguageChanged) then) =
      _$AppLanguageChangedCopyWithImpl<$Res, AppLanguageChanged>;
  @useResult
  $Res call({String locale});
}

/// @nodoc
class _$AppLanguageChangedCopyWithImpl<$Res, $Val extends AppLanguageChanged>
    implements $AppLanguageChangedCopyWith<$Res> {
  _$AppLanguageChangedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? locale = null,
  }) {
    return _then(_value.copyWith(
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AppLanguageChangedImplCopyWith<$Res>
    implements $AppLanguageChangedCopyWith<$Res> {
  factory _$$AppLanguageChangedImplCopyWith(_$AppLanguageChangedImpl value,
          $Res Function(_$AppLanguageChangedImpl) then) =
      __$$AppLanguageChangedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String locale});
}

/// @nodoc
class __$$AppLanguageChangedImplCopyWithImpl<$Res>
    extends _$AppLanguageChangedCopyWithImpl<$Res, _$AppLanguageChangedImpl>
    implements _$$AppLanguageChangedImplCopyWith<$Res> {
  __$$AppLanguageChangedImplCopyWithImpl(_$AppLanguageChangedImpl _value,
      $Res Function(_$AppLanguageChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? locale = null,
  }) {
    return _then(_$AppLanguageChangedImpl(
      null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AppLanguageChangedImpl implements _AppLanguageChanged {
  const _$AppLanguageChangedImpl(this.locale);

  @override
  final String locale;

  @override
  String toString() {
    return 'AppLanguageChanged(locale: $locale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppLanguageChangedImpl &&
            (identical(other.locale, locale) || other.locale == locale));
  }

  @override
  int get hashCode => Object.hash(runtimeType, locale);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppLanguageChangedImplCopyWith<_$AppLanguageChangedImpl> get copyWith =>
      __$$AppLanguageChangedImplCopyWithImpl<_$AppLanguageChangedImpl>(
          this, _$identity);
}

abstract class _AppLanguageChanged implements AppLanguageChanged {
  const factory _AppLanguageChanged(final String locale) =
      _$AppLanguageChangedImpl;

  @override
  String get locale;
  @override
  @JsonKey(ignore: true)
  _$$AppLanguageChangedImplCopyWith<_$AppLanguageChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AppPaletteChanged {
  String get name => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AppPaletteChangedCopyWith<AppPaletteChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppPaletteChangedCopyWith<$Res> {
  factory $AppPaletteChangedCopyWith(
          AppPaletteChanged value, $Res Function(AppPaletteChanged) then) =
      _$AppPaletteChangedCopyWithImpl<$Res, AppPaletteChanged>;
  @useResult
  $Res call({String name});
}

/// @nodoc
class _$AppPaletteChangedCopyWithImpl<$Res, $Val extends AppPaletteChanged>
    implements $AppPaletteChangedCopyWith<$Res> {
  _$AppPaletteChangedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AppPaletteChangedImplCopyWith<$Res>
    implements $AppPaletteChangedCopyWith<$Res> {
  factory _$$AppPaletteChangedImplCopyWith(_$AppPaletteChangedImpl value,
          $Res Function(_$AppPaletteChangedImpl) then) =
      __$$AppPaletteChangedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name});
}

/// @nodoc
class __$$AppPaletteChangedImplCopyWithImpl<$Res>
    extends _$AppPaletteChangedCopyWithImpl<$Res, _$AppPaletteChangedImpl>
    implements _$$AppPaletteChangedImplCopyWith<$Res> {
  __$$AppPaletteChangedImplCopyWithImpl(_$AppPaletteChangedImpl _value,
      $Res Function(_$AppPaletteChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
  }) {
    return _then(_$AppPaletteChangedImpl(
      null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$AppPaletteChangedImpl implements _AppPaletteChanged {
  const _$AppPaletteChangedImpl(this.name);

  @override
  final String name;

  @override
  String toString() {
    return 'AppPaletteChanged(name: $name)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppPaletteChangedImpl &&
            (identical(other.name, name) || other.name == name));
  }

  @override
  int get hashCode => Object.hash(runtimeType, name);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppPaletteChangedImplCopyWith<_$AppPaletteChangedImpl> get copyWith =>
      __$$AppPaletteChangedImplCopyWithImpl<_$AppPaletteChangedImpl>(
          this, _$identity);
}

abstract class _AppPaletteChanged implements AppPaletteChanged {
  const factory _AppPaletteChanged(final String name) = _$AppPaletteChangedImpl;

  @override
  String get name;
  @override
  @JsonKey(ignore: true)
  _$$AppPaletteChangedImplCopyWith<_$AppPaletteChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AppResumed {}

/// @nodoc
abstract class $AppResumedCopyWith<$Res> {
  factory $AppResumedCopyWith(
          AppResumed value, $Res Function(AppResumed) then) =
      _$AppResumedCopyWithImpl<$Res, AppResumed>;
}

/// @nodoc
class _$AppResumedCopyWithImpl<$Res, $Val extends AppResumed>
    implements $AppResumedCopyWith<$Res> {
  _$AppResumedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AppResumedImplCopyWith<$Res> {
  factory _$$AppResumedImplCopyWith(
          _$AppResumedImpl value, $Res Function(_$AppResumedImpl) then) =
      __$$AppResumedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AppResumedImplCopyWithImpl<$Res>
    extends _$AppResumedCopyWithImpl<$Res, _$AppResumedImpl>
    implements _$$AppResumedImplCopyWith<$Res> {
  __$$AppResumedImplCopyWithImpl(
      _$AppResumedImpl _value, $Res Function(_$AppResumedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AppResumedImpl implements _AppResumed {
  const _$AppResumedImpl();

  @override
  String toString() {
    return 'AppResumed()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$AppResumedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _AppResumed implements AppResumed {
  const factory _AppResumed() = _$AppResumedImpl;
}

/// @nodoc
mixin _$AppThemeChanged {
  bool get isDarkTheme => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AppThemeChangedCopyWith<AppThemeChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppThemeChangedCopyWith<$Res> {
  factory $AppThemeChangedCopyWith(
          AppThemeChanged value, $Res Function(AppThemeChanged) then) =
      _$AppThemeChangedCopyWithImpl<$Res, AppThemeChanged>;
  @useResult
  $Res call({bool isDarkTheme});
}

/// @nodoc
class _$AppThemeChangedCopyWithImpl<$Res, $Val extends AppThemeChanged>
    implements $AppThemeChangedCopyWith<$Res> {
  _$AppThemeChangedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isDarkTheme = null,
  }) {
    return _then(_value.copyWith(
      isDarkTheme: null == isDarkTheme
          ? _value.isDarkTheme
          : isDarkTheme // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AppThemeChangedImplCopyWith<$Res>
    implements $AppThemeChangedCopyWith<$Res> {
  factory _$$AppThemeChangedImplCopyWith(_$AppThemeChangedImpl value,
          $Res Function(_$AppThemeChangedImpl) then) =
      __$$AppThemeChangedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({bool isDarkTheme});
}

/// @nodoc
class __$$AppThemeChangedImplCopyWithImpl<$Res>
    extends _$AppThemeChangedCopyWithImpl<$Res, _$AppThemeChangedImpl>
    implements _$$AppThemeChangedImplCopyWith<$Res> {
  __$$AppThemeChangedImplCopyWithImpl(
      _$AppThemeChangedImpl _value, $Res Function(_$AppThemeChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isDarkTheme = null,
  }) {
    return _then(_$AppThemeChangedImpl(
      null == isDarkTheme
          ? _value.isDarkTheme
          : isDarkTheme // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$AppThemeChangedImpl implements _AppThemeChanged {
  const _$AppThemeChangedImpl(this.isDarkTheme);

  @override
  final bool isDarkTheme;

  @override
  String toString() {
    return 'AppThemeChanged(isDarkTheme: $isDarkTheme)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppThemeChangedImpl &&
            (identical(other.isDarkTheme, isDarkTheme) ||
                other.isDarkTheme == isDarkTheme));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isDarkTheme);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppThemeChangedImplCopyWith<_$AppThemeChangedImpl> get copyWith =>
      __$$AppThemeChangedImplCopyWithImpl<_$AppThemeChangedImpl>(
          this, _$identity);
}

abstract class _AppThemeChanged implements AppThemeChanged {
  const factory _AppThemeChanged(final bool isDarkTheme) =
      _$AppThemeChangedImpl;

  @override
  bool get isDarkTheme;
  @override
  @JsonKey(ignore: true)
  _$$AppThemeChangedImplCopyWith<_$AppThemeChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GetAppServerConfig {}

/// @nodoc
abstract class $GetAppServerConfigCopyWith<$Res> {
  factory $GetAppServerConfigCopyWith(
          GetAppServerConfig value, $Res Function(GetAppServerConfig) then) =
      _$GetAppServerConfigCopyWithImpl<$Res, GetAppServerConfig>;
}

/// @nodoc
class _$GetAppServerConfigCopyWithImpl<$Res, $Val extends GetAppServerConfig>
    implements $GetAppServerConfigCopyWith<$Res> {
  _$GetAppServerConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetAppServerConfigImplCopyWith<$Res> {
  factory _$$GetAppServerConfigImplCopyWith(_$GetAppServerConfigImpl value,
          $Res Function(_$GetAppServerConfigImpl) then) =
      __$$GetAppServerConfigImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetAppServerConfigImplCopyWithImpl<$Res>
    extends _$GetAppServerConfigCopyWithImpl<$Res, _$GetAppServerConfigImpl>
    implements _$$GetAppServerConfigImplCopyWith<$Res> {
  __$$GetAppServerConfigImplCopyWithImpl(_$GetAppServerConfigImpl _value,
      $Res Function(_$GetAppServerConfigImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetAppServerConfigImpl implements _GetAppServerConfig {
  const _$GetAppServerConfigImpl();

  @override
  String toString() {
    return 'GetAppServerConfig()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$GetAppServerConfigImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _GetAppServerConfig implements GetAppServerConfig {
  const factory _GetAppServerConfig() = _$GetAppServerConfigImpl;
}

/// @nodoc
mixin _$GetCurrentUser {
  FutureOr<void> Function(User)? get onSuccess =>
      throw _privateConstructorUsedError;
  FutureOr<void> Function(Object)? get onError =>
      throw _privateConstructorUsedError;
  bool get checkContractStatus => throw _privateConstructorUsedError;
  Completer<void>? get completer => throw _privateConstructorUsedError;
  bool get forceRefreshToken => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $GetCurrentUserCopyWith<GetCurrentUser> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetCurrentUserCopyWith<$Res> {
  factory $GetCurrentUserCopyWith(
          GetCurrentUser value, $Res Function(GetCurrentUser) then) =
      _$GetCurrentUserCopyWithImpl<$Res, GetCurrentUser>;
  @useResult
  $Res call(
      {FutureOr<void> Function(User)? onSuccess,
      FutureOr<void> Function(Object)? onError,
      bool checkContractStatus,
      Completer<void>? completer,
      bool forceRefreshToken});
}

/// @nodoc
class _$GetCurrentUserCopyWithImpl<$Res, $Val extends GetCurrentUser>
    implements $GetCurrentUserCopyWith<$Res> {
  _$GetCurrentUserCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onSuccess = freezed,
    Object? onError = freezed,
    Object? checkContractStatus = null,
    Object? completer = freezed,
    Object? forceRefreshToken = null,
  }) {
    return _then(_value.copyWith(
      onSuccess: freezed == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(User)?,
      onError: freezed == onError
          ? _value.onError
          : onError // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(Object)?,
      checkContractStatus: null == checkContractStatus
          ? _value.checkContractStatus
          : checkContractStatus // ignore: cast_nullable_to_non_nullable
              as bool,
      completer: freezed == completer
          ? _value.completer
          : completer // ignore: cast_nullable_to_non_nullable
              as Completer<void>?,
      forceRefreshToken: null == forceRefreshToken
          ? _value.forceRefreshToken
          : forceRefreshToken // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GetCurrentUserImplCopyWith<$Res>
    implements $GetCurrentUserCopyWith<$Res> {
  factory _$$GetCurrentUserImplCopyWith(_$GetCurrentUserImpl value,
          $Res Function(_$GetCurrentUserImpl) then) =
      __$$GetCurrentUserImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {FutureOr<void> Function(User)? onSuccess,
      FutureOr<void> Function(Object)? onError,
      bool checkContractStatus,
      Completer<void>? completer,
      bool forceRefreshToken});
}

/// @nodoc
class __$$GetCurrentUserImplCopyWithImpl<$Res>
    extends _$GetCurrentUserCopyWithImpl<$Res, _$GetCurrentUserImpl>
    implements _$$GetCurrentUserImplCopyWith<$Res> {
  __$$GetCurrentUserImplCopyWithImpl(
      _$GetCurrentUserImpl _value, $Res Function(_$GetCurrentUserImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onSuccess = freezed,
    Object? onError = freezed,
    Object? checkContractStatus = null,
    Object? completer = freezed,
    Object? forceRefreshToken = null,
  }) {
    return _then(_$GetCurrentUserImpl(
      onSuccess: freezed == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(User)?,
      onError: freezed == onError
          ? _value.onError
          : onError // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(Object)?,
      checkContractStatus: null == checkContractStatus
          ? _value.checkContractStatus
          : checkContractStatus // ignore: cast_nullable_to_non_nullable
              as bool,
      completer: freezed == completer
          ? _value.completer
          : completer // ignore: cast_nullable_to_non_nullable
              as Completer<void>?,
      forceRefreshToken: null == forceRefreshToken
          ? _value.forceRefreshToken
          : forceRefreshToken // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$GetCurrentUserImpl implements _GetCurrentUser {
  const _$GetCurrentUserImpl(
      {this.onSuccess,
      this.onError,
      this.checkContractStatus = false,
      this.completer,
      this.forceRefreshToken = false});

  @override
  final FutureOr<void> Function(User)? onSuccess;
  @override
  final FutureOr<void> Function(Object)? onError;
  @override
  @JsonKey()
  final bool checkContractStatus;
  @override
  final Completer<void>? completer;
  @override
  @JsonKey()
  final bool forceRefreshToken;

  @override
  String toString() {
    return 'GetCurrentUser(onSuccess: $onSuccess, onError: $onError, checkContractStatus: $checkContractStatus, completer: $completer, forceRefreshToken: $forceRefreshToken)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetCurrentUserImpl &&
            (identical(other.onSuccess, onSuccess) ||
                other.onSuccess == onSuccess) &&
            (identical(other.onError, onError) || other.onError == onError) &&
            (identical(other.checkContractStatus, checkContractStatus) ||
                other.checkContractStatus == checkContractStatus) &&
            (identical(other.completer, completer) ||
                other.completer == completer) &&
            (identical(other.forceRefreshToken, forceRefreshToken) ||
                other.forceRefreshToken == forceRefreshToken));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onSuccess, onError,
      checkContractStatus, completer, forceRefreshToken);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetCurrentUserImplCopyWith<_$GetCurrentUserImpl> get copyWith =>
      __$$GetCurrentUserImplCopyWithImpl<_$GetCurrentUserImpl>(
          this, _$identity);
}

abstract class _GetCurrentUser implements GetCurrentUser {
  const factory _GetCurrentUser(
      {final FutureOr<void> Function(User)? onSuccess,
      final FutureOr<void> Function(Object)? onError,
      final bool checkContractStatus,
      final Completer<void>? completer,
      final bool forceRefreshToken}) = _$GetCurrentUserImpl;

  @override
  FutureOr<void> Function(User)? get onSuccess;
  @override
  FutureOr<void> Function(Object)? get onError;
  @override
  bool get checkContractStatus;
  @override
  Completer<void>? get completer;
  @override
  bool get forceRefreshToken;
  @override
  @JsonKey(ignore: true)
  _$$GetCurrentUserImplCopyWith<_$GetCurrentUserImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GetEntities {
  FutureOr<void> Function(List<Entity>)? get onSuccess =>
      throw _privateConstructorUsedError;
  FutureOr<void> Function(Object)? get onError =>
      throw _privateConstructorUsedError;
  bool get checkContractStatus => throw _privateConstructorUsedError;
  Completer<void>? get completer => throw _privateConstructorUsedError;
  bool get forceRefreshToken => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $GetEntitiesCopyWith<GetEntities> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GetEntitiesCopyWith<$Res> {
  factory $GetEntitiesCopyWith(
          GetEntities value, $Res Function(GetEntities) then) =
      _$GetEntitiesCopyWithImpl<$Res, GetEntities>;
  @useResult
  $Res call(
      {FutureOr<void> Function(List<Entity>)? onSuccess,
      FutureOr<void> Function(Object)? onError,
      bool checkContractStatus,
      Completer<void>? completer,
      bool forceRefreshToken});
}

/// @nodoc
class _$GetEntitiesCopyWithImpl<$Res, $Val extends GetEntities>
    implements $GetEntitiesCopyWith<$Res> {
  _$GetEntitiesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onSuccess = freezed,
    Object? onError = freezed,
    Object? checkContractStatus = null,
    Object? completer = freezed,
    Object? forceRefreshToken = null,
  }) {
    return _then(_value.copyWith(
      onSuccess: freezed == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(List<Entity>)?,
      onError: freezed == onError
          ? _value.onError
          : onError // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(Object)?,
      checkContractStatus: null == checkContractStatus
          ? _value.checkContractStatus
          : checkContractStatus // ignore: cast_nullable_to_non_nullable
              as bool,
      completer: freezed == completer
          ? _value.completer
          : completer // ignore: cast_nullable_to_non_nullable
              as Completer<void>?,
      forceRefreshToken: null == forceRefreshToken
          ? _value.forceRefreshToken
          : forceRefreshToken // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$GetEntitiesImplCopyWith<$Res>
    implements $GetEntitiesCopyWith<$Res> {
  factory _$$GetEntitiesImplCopyWith(
          _$GetEntitiesImpl value, $Res Function(_$GetEntitiesImpl) then) =
      __$$GetEntitiesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {FutureOr<void> Function(List<Entity>)? onSuccess,
      FutureOr<void> Function(Object)? onError,
      bool checkContractStatus,
      Completer<void>? completer,
      bool forceRefreshToken});
}

/// @nodoc
class __$$GetEntitiesImplCopyWithImpl<$Res>
    extends _$GetEntitiesCopyWithImpl<$Res, _$GetEntitiesImpl>
    implements _$$GetEntitiesImplCopyWith<$Res> {
  __$$GetEntitiesImplCopyWithImpl(
      _$GetEntitiesImpl _value, $Res Function(_$GetEntitiesImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? onSuccess = freezed,
    Object? onError = freezed,
    Object? checkContractStatus = null,
    Object? completer = freezed,
    Object? forceRefreshToken = null,
  }) {
    return _then(_$GetEntitiesImpl(
      onSuccess: freezed == onSuccess
          ? _value.onSuccess
          : onSuccess // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(List<Entity>)?,
      onError: freezed == onError
          ? _value.onError
          : onError // ignore: cast_nullable_to_non_nullable
              as FutureOr<void> Function(Object)?,
      checkContractStatus: null == checkContractStatus
          ? _value.checkContractStatus
          : checkContractStatus // ignore: cast_nullable_to_non_nullable
              as bool,
      completer: freezed == completer
          ? _value.completer
          : completer // ignore: cast_nullable_to_non_nullable
              as Completer<void>?,
      forceRefreshToken: null == forceRefreshToken
          ? _value.forceRefreshToken
          : forceRefreshToken // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$GetEntitiesImpl implements _GetEntities {
  const _$GetEntitiesImpl(
      {this.onSuccess,
      this.onError,
      this.checkContractStatus = false,
      this.completer,
      this.forceRefreshToken = false});

  @override
  final FutureOr<void> Function(List<Entity>)? onSuccess;
  @override
  final FutureOr<void> Function(Object)? onError;
  @override
  @JsonKey()
  final bool checkContractStatus;
  @override
  final Completer<void>? completer;
  @override
  @JsonKey()
  final bool forceRefreshToken;

  @override
  String toString() {
    return 'GetEntities(onSuccess: $onSuccess, onError: $onError, checkContractStatus: $checkContractStatus, completer: $completer, forceRefreshToken: $forceRefreshToken)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetEntitiesImpl &&
            (identical(other.onSuccess, onSuccess) ||
                other.onSuccess == onSuccess) &&
            (identical(other.onError, onError) || other.onError == onError) &&
            (identical(other.checkContractStatus, checkContractStatus) ||
                other.checkContractStatus == checkContractStatus) &&
            (identical(other.completer, completer) ||
                other.completer == completer) &&
            (identical(other.forceRefreshToken, forceRefreshToken) ||
                other.forceRefreshToken == forceRefreshToken));
  }

  @override
  int get hashCode => Object.hash(runtimeType, onSuccess, onError,
      checkContractStatus, completer, forceRefreshToken);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$GetEntitiesImplCopyWith<_$GetEntitiesImpl> get copyWith =>
      __$$GetEntitiesImplCopyWithImpl<_$GetEntitiesImpl>(this, _$identity);
}

abstract class _GetEntities implements GetEntities {
  const factory _GetEntities(
      {final FutureOr<void> Function(List<Entity>)? onSuccess,
      final FutureOr<void> Function(Object)? onError,
      final bool checkContractStatus,
      final Completer<void>? completer,
      final bool forceRefreshToken}) = _$GetEntitiesImpl;

  @override
  FutureOr<void> Function(List<Entity>)? get onSuccess;
  @override
  FutureOr<void> Function(Object)? get onError;
  @override
  bool get checkContractStatus;
  @override
  Completer<void>? get completer;
  @override
  bool get forceRefreshToken;
  @override
  @JsonKey(ignore: true)
  _$$GetEntitiesImplCopyWith<_$GetEntitiesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$GetUserSignContractStatus {}

/// @nodoc
abstract class $GetUserSignContractStatusCopyWith<$Res> {
  factory $GetUserSignContractStatusCopyWith(GetUserSignContractStatus value,
          $Res Function(GetUserSignContractStatus) then) =
      _$GetUserSignContractStatusCopyWithImpl<$Res, GetUserSignContractStatus>;
}

/// @nodoc
class _$GetUserSignContractStatusCopyWithImpl<$Res,
        $Val extends GetUserSignContractStatus>
    implements $GetUserSignContractStatusCopyWith<$Res> {
  _$GetUserSignContractStatusCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$GetUserSignContractStatusImplCopyWith<$Res> {
  factory _$$GetUserSignContractStatusImplCopyWith(
          _$GetUserSignContractStatusImpl value,
          $Res Function(_$GetUserSignContractStatusImpl) then) =
      __$$GetUserSignContractStatusImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$GetUserSignContractStatusImplCopyWithImpl<$Res>
    extends _$GetUserSignContractStatusCopyWithImpl<$Res,
        _$GetUserSignContractStatusImpl>
    implements _$$GetUserSignContractStatusImplCopyWith<$Res> {
  __$$GetUserSignContractStatusImplCopyWithImpl(
      _$GetUserSignContractStatusImpl _value,
      $Res Function(_$GetUserSignContractStatusImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$GetUserSignContractStatusImpl implements _GetUserSignContractStatus {
  const _$GetUserSignContractStatusImpl();

  @override
  String toString() {
    return 'GetUserSignContractStatus()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetUserSignContractStatusImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;
}

abstract class _GetUserSignContractStatus implements GetUserSignContractStatus {
  const factory _GetUserSignContractStatus() = _$GetUserSignContractStatusImpl;
}

/// @nodoc
mixin _$LoggedUserChanged {
  User? get user => throw _privateConstructorUsedError;
  bool? get hasSignedContract => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $LoggedUserChangedCopyWith<LoggedUserChanged> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoggedUserChangedCopyWith<$Res> {
  factory $LoggedUserChangedCopyWith(
          LoggedUserChanged value, $Res Function(LoggedUserChanged) then) =
      _$LoggedUserChangedCopyWithImpl<$Res, LoggedUserChanged>;
  @useResult
  $Res call({User? user, bool? hasSignedContract});
}

/// @nodoc
class _$LoggedUserChangedCopyWithImpl<$Res, $Val extends LoggedUserChanged>
    implements $LoggedUserChangedCopyWith<$Res> {
  _$LoggedUserChangedCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = freezed,
    Object? hasSignedContract = freezed,
  }) {
    return _then(_value.copyWith(
      user: freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      hasSignedContract: freezed == hasSignedContract
          ? _value.hasSignedContract
          : hasSignedContract // ignore: cast_nullable_to_non_nullable
              as bool?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$LoggedUserChangedImplCopyWith<$Res>
    implements $LoggedUserChangedCopyWith<$Res> {
  factory _$$LoggedUserChangedImplCopyWith(_$LoggedUserChangedImpl value,
          $Res Function(_$LoggedUserChangedImpl) then) =
      __$$LoggedUserChangedImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({User? user, bool? hasSignedContract});
}

/// @nodoc
class __$$LoggedUserChangedImplCopyWithImpl<$Res>
    extends _$LoggedUserChangedCopyWithImpl<$Res, _$LoggedUserChangedImpl>
    implements _$$LoggedUserChangedImplCopyWith<$Res> {
  __$$LoggedUserChangedImplCopyWithImpl(_$LoggedUserChangedImpl _value,
      $Res Function(_$LoggedUserChangedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? user = freezed,
    Object? hasSignedContract = freezed,
  }) {
    return _then(_$LoggedUserChangedImpl(
      freezed == user
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as User?,
      hasSignedContract: freezed == hasSignedContract
          ? _value.hasSignedContract
          : hasSignedContract // ignore: cast_nullable_to_non_nullable
              as bool?,
    ));
  }
}

/// @nodoc

class _$LoggedUserChangedImpl implements _LoggedUserChanged {
  const _$LoggedUserChangedImpl(this.user, {this.hasSignedContract});

  @override
  final User? user;
  @override
  final bool? hasSignedContract;

  @override
  String toString() {
    return 'LoggedUserChanged(user: $user, hasSignedContract: $hasSignedContract)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoggedUserChangedImpl &&
            (identical(other.user, user) || other.user == user) &&
            (identical(other.hasSignedContract, hasSignedContract) ||
                other.hasSignedContract == hasSignedContract));
  }

  @override
  int get hashCode => Object.hash(runtimeType, user, hasSignedContract);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoggedUserChangedImplCopyWith<_$LoggedUserChangedImpl> get copyWith =>
      __$$LoggedUserChangedImplCopyWithImpl<_$LoggedUserChangedImpl>(
          this, _$identity);
}

abstract class _LoggedUserChanged implements LoggedUserChanged {
  const factory _LoggedUserChanged(final User? user,
      {final bool? hasSignedContract}) = _$LoggedUserChangedImpl;

  @override
  User? get user;
  @override
  bool? get hasSignedContract;
  @override
  @JsonKey(ignore: true)
  _$$LoggedUserChangedImplCopyWith<_$LoggedUserChangedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

AppState _$AppStateFromJson(Map<String, dynamic> json) {
  return _AppState.fromJson(json);
}

/// @nodoc
mixin _$AppState {
  User? get currentUser => throw _privateConstructorUsedError;
  String? get lastUserId => throw _privateConstructorUsedError;
  dynamic get palette => throw _privateConstructorUsedError;
  dynamic get isForceUpdate => throw _privateConstructorUsedError;
  dynamic get isMaintaining => throw _privateConstructorUsedError;
  bool get isDarkTheme => throw _privateConstructorUsedError;
  String get locale => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $AppStateCopyWith<AppState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AppStateCopyWith<$Res> {
  factory $AppStateCopyWith(AppState value, $Res Function(AppState) then) =
      _$AppStateCopyWithImpl<$Res, AppState>;
  @useResult
  $Res call(
      {User? currentUser,
      String? lastUserId,
      dynamic palette,
      dynamic isForceUpdate,
      dynamic isMaintaining,
      bool isDarkTheme,
      String locale});
}

/// @nodoc
class _$AppStateCopyWithImpl<$Res, $Val extends AppState>
    implements $AppStateCopyWith<$Res> {
  _$AppStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentUser = freezed,
    Object? lastUserId = freezed,
    Object? palette = freezed,
    Object? isForceUpdate = freezed,
    Object? isMaintaining = freezed,
    Object? isDarkTheme = null,
    Object? locale = null,
  }) {
    return _then(_value.copyWith(
      currentUser: freezed == currentUser
          ? _value.currentUser
          : currentUser // ignore: cast_nullable_to_non_nullable
              as User?,
      lastUserId: freezed == lastUserId
          ? _value.lastUserId
          : lastUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      palette: freezed == palette
          ? _value.palette
          : palette // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isForceUpdate: freezed == isForceUpdate
          ? _value.isForceUpdate
          : isForceUpdate // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isMaintaining: freezed == isMaintaining
          ? _value.isMaintaining
          : isMaintaining // ignore: cast_nullable_to_non_nullable
              as dynamic,
      isDarkTheme: null == isDarkTheme
          ? _value.isDarkTheme
          : isDarkTheme // ignore: cast_nullable_to_non_nullable
              as bool,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$AppStateImplCopyWith<$Res>
    implements $AppStateCopyWith<$Res> {
  factory _$$AppStateImplCopyWith(
          _$AppStateImpl value, $Res Function(_$AppStateImpl) then) =
      __$$AppStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {User? currentUser,
      String? lastUserId,
      dynamic palette,
      dynamic isForceUpdate,
      dynamic isMaintaining,
      bool isDarkTheme,
      String locale});
}

/// @nodoc
class __$$AppStateImplCopyWithImpl<$Res>
    extends _$AppStateCopyWithImpl<$Res, _$AppStateImpl>
    implements _$$AppStateImplCopyWith<$Res> {
  __$$AppStateImplCopyWithImpl(
      _$AppStateImpl _value, $Res Function(_$AppStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentUser = freezed,
    Object? lastUserId = freezed,
    Object? palette = freezed,
    Object? isForceUpdate = freezed,
    Object? isMaintaining = freezed,
    Object? isDarkTheme = null,
    Object? locale = null,
  }) {
    return _then(_$AppStateImpl(
      currentUser: freezed == currentUser
          ? _value.currentUser
          : currentUser // ignore: cast_nullable_to_non_nullable
              as User?,
      lastUserId: freezed == lastUserId
          ? _value.lastUserId
          : lastUserId // ignore: cast_nullable_to_non_nullable
              as String?,
      palette: freezed == palette ? _value.palette! : palette,
      isForceUpdate:
          freezed == isForceUpdate ? _value.isForceUpdate! : isForceUpdate,
      isMaintaining:
          freezed == isMaintaining ? _value.isMaintaining! : isMaintaining,
      isDarkTheme: null == isDarkTheme
          ? _value.isDarkTheme
          : isDarkTheme // ignore: cast_nullable_to_non_nullable
              as bool,
      locale: null == locale
          ? _value.locale
          : locale // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$AppStateImpl extends _AppState {
  const _$AppStateImpl(
      {this.currentUser,
      this.lastUserId,
      this.palette = 'Blue',
      this.isForceUpdate = false,
      this.isMaintaining = false,
      this.isDarkTheme = false,
      this.locale = LocaleConfig.defaultLocale})
      : super._();

  factory _$AppStateImpl.fromJson(Map<String, dynamic> json) =>
      _$$AppStateImplFromJson(json);

  @override
  final User? currentUser;
  @override
  final String? lastUserId;
  @override
  @JsonKey()
  final dynamic palette;
  @override
  @JsonKey()
  final dynamic isForceUpdate;
  @override
  @JsonKey()
  final dynamic isMaintaining;
  @override
  @JsonKey()
  final bool isDarkTheme;
  @override
  @JsonKey()
  final String locale;

  @override
  String toString() {
    return 'AppState(currentUser: $currentUser, lastUserId: $lastUserId, palette: $palette, isForceUpdate: $isForceUpdate, isMaintaining: $isMaintaining, isDarkTheme: $isDarkTheme, locale: $locale)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AppStateImpl &&
            (identical(other.currentUser, currentUser) ||
                other.currentUser == currentUser) &&
            (identical(other.lastUserId, lastUserId) ||
                other.lastUserId == lastUserId) &&
            const DeepCollectionEquality().equals(other.palette, palette) &&
            const DeepCollectionEquality()
                .equals(other.isForceUpdate, isForceUpdate) &&
            const DeepCollectionEquality()
                .equals(other.isMaintaining, isMaintaining) &&
            (identical(other.isDarkTheme, isDarkTheme) ||
                other.isDarkTheme == isDarkTheme) &&
            (identical(other.locale, locale) || other.locale == locale));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      currentUser,
      lastUserId,
      const DeepCollectionEquality().hash(palette),
      const DeepCollectionEquality().hash(isForceUpdate),
      const DeepCollectionEquality().hash(isMaintaining),
      isDarkTheme,
      locale);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$AppStateImplCopyWith<_$AppStateImpl> get copyWith =>
      __$$AppStateImplCopyWithImpl<_$AppStateImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AppStateImplToJson(
      this,
    );
  }
}

abstract class _AppState extends AppState {
  const factory _AppState(
      {final User? currentUser,
      final String? lastUserId,
      final dynamic palette,
      final dynamic isForceUpdate,
      final dynamic isMaintaining,
      final bool isDarkTheme,
      final String locale}) = _$AppStateImpl;
  const _AppState._() : super._();

  factory _AppState.fromJson(Map<String, dynamic> json) =
      _$AppStateImpl.fromJson;

  @override
  User? get currentUser;
  @override
  String? get lastUserId;
  @override
  dynamic get palette;
  @override
  dynamic get isForceUpdate;
  @override
  dynamic get isMaintaining;
  @override
  bool get isDarkTheme;
  @override
  String get locale;
  @override
  @JsonKey(ignore: true)
  _$$AppStateImplCopyWith<_$AppStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
